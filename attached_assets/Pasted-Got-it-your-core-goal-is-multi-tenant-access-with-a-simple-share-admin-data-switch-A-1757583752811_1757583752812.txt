Got it — your core goal is **multi-tenant access** with a simple “share admin data” switch:

* **Admin (you):** sees everything (own + any user who opted to share with admin).
* **Team user (share ON):** sees **admin’s** data + their own.
* **Team user (share OFF):** sees **only their own** (must add their own WA instance creds).

Right now you’re blocked by two things:

1. an **auth header / request path** that your “All Records” page isn’t sending through the shared fetch layer, and
2. a **UUID filter bug** (already half-fixed) + **inconsistent access filter** across endpoints.

Below is a tight, copy-pasteable set of patches that will make this work end-to-end.

---

# 1) Minimal schema assumptions

These fields should exist in your `users` table (Drizzle / Postgres):

```ts
// server/db/schema.ts
export const users = pgTable('users', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: text('email').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  isAdmin: boolean('is_admin').notNull().default(false),
  shareAdminData: boolean('share_admin_data').notNull().default(false),
  adminId: uuid('admin_id'), // nullable: for non-admins who “attach” to an admin
  // ... timestamps etc.
});
```

* **Admin user**: `isAdmin=true`, `adminId=null`, `shareAdminData` doesn’t matter.
* **Team user sharing admin data**: `isAdmin=false`, `adminId=<ADMIN_UUID>`, `shareAdminData=true`.
* **Team user not sharing**: `isAdmin=false`, `adminId=<ADMIN_UUID | null>`, `shareAdminData=false`.

If you don’t have `adminId` yet, add it (nullable). It makes the access logic clean.

---

# 2) One access-control helper (use everywhere)

Create this once and reuse in every “list/search/export” endpoint so behavior is consistent.

```ts
// server/lib/access.ts
import { and, eq, or, inArray } from 'drizzle-orm';
import { db } from '../db/client';
import { users } from '../db/schema';

export type AuthUser = {
  id: string;
  isAdmin: boolean;
  shareAdminData: boolean;
  adminId: string | null;
};

export async function getAccessibleUserIds(current: AuthUser): Promise<string[]> {
  // Admin: see admin + any user who opted to share with admin
  if (current.isAdmin) {
    const rows = await db
      .select({ id: users.id })
      .from(users)
      .where(or(eq(users.id, current.id), eq(users.shareAdminData, true)));
    return rows.map(r => r.id);
  }

  // Team user sharing admin: see self + admin
  if (current.shareAdminData && current.adminId) {
    return [current.id, current.adminId];
  }

  // Team user not sharing: only self
  return [current.id];
}

/** Safe inArray that handles empty lists by returning `false` condition */
export function inArraySafe<T>(column: any, ids: T[]) {
  return ids.length ? inArray(column, ids) : eq(column, '__never__'); // never matches
}
```

---

# 3) Fix the listings query (Drizzle syntax, no manual quoting)

```ts
// server/storage.ts (or wherever getWatchListings lives)
import { and } from 'drizzle-orm';
import { getAccessibleUserIds, inArraySafe } from './lib/access';
import { watchListings } from './db/schema';

export async function getWatchListings(db, user: AuthUser, params: {
  limit: number; offset: number;
  q?: string; brand?: string; // etc.
}) {
  const ids = await getAccessibleUserIds(user);

  const whereParts: any[] = [ inArraySafe(watchListings.userId, ids) ];

  if (params.q) {
    // add your text search conditions here (brand/model/ref, etc.)
  }
  if (params.brand) {
    whereParts.push(eq(watchListings.brand, params.brand));
  }

  const where = and(...whereParts);

  const [items, [{ total }]] = await Promise.all([
    db.select().from(watchListings)
      .where(where)
      .limit(params.limit)
      .offset(params.offset),

    db.select({ total: sql<number>`count(*)` })
      .from(watchListings)
      .where(where),
  ]);

  return { items, total };
}
```

> **Why this fixes the crash:** We never manually quote UUIDs. `inArray` gets real UUIDs, not `" 'uuid' "`.
> **Why this fixes “wrong data”:** Every list endpoint uses **the same access filter**.

---

# 4) Use the same access filter for **all** endpoints

Apply the **same** pattern to:

* `/api/watch-listings/search`
* `/api/incoming-messages`
* `/api/whatsapp/requests`
* `/api/exports/...`

Anywhere you previously filtered by `userId`, switch to:

```ts
const ids = await getAccessibleUserIds(req.user);
const where = and(inArraySafe(Table.userId, ids), /* other filters */);
```

This instantly aligns “All Records”, “Incoming”, “Req”, “Exports” with the **exact same visibility** rules.

---

# 5) Make sure the client actually sends the token for All Records

Your debugging notes show the token was attached to some endpoints but **not** the listings search. The cause is typically a page bypassing your central fetch.

Ensure **all** API calls go through one wrapper (Axios or fetch). Example with Axios:

```ts
// client/src/lib/api.ts
import axios from 'axios';

export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL ?? '/api',
  withCredentials: false,
});

api.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});
```

Then in your queries:

```ts
// client/src/services/watchListings.ts
import { api } from '../lib/api';

export async function searchWatchListings(params: { limit: number; offset: number; q?: string }) {
  const { data } = await api.get('/watch-listings/search', { params });
  // Ensure the server returns { items, total }
  return data as { items: any[]; total: number };
}
```

And the page:

```tsx
// client/src/pages/records.tsx
import { useQuery } from '@tanstack/react-query';
import { searchWatchListings } from '@/services/watchListings';

export default function RecordsPage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['watch-listings', { limit: 50, offset: 0 }],
    queryFn: () => searchWatchListings({ limit: 50, offset: 0 }),
    staleTime: 30_000,
  });

  if (isLoading) return <div>Loading…</div>;
  if (error) return <div>Failed to load</div>;

  // data.items, data.total — keep UI data mapping strict
  return (/* render table with data.items */);
}
```

> **Common gotcha:** If the All Records page imported a direct `fetch('/api/watch-listings/search')` somewhere, it **won’t** have the interceptor, so your token never goes out. Convert that to use the `api` instance.

---

# 6) Ensure the server always returns a consistent response shape

The page expects `{ items, total }`. Make sure your controller does exactly that:

```ts
// server/routes/watchListings.ts
app.get('/api/watch-listings/search', authMiddleware, async (req, res) => {
  const limit = Number(req.query.limit ?? 50);
  const offset = Number(req.query.offset ?? 0);

  const result = await getWatchListings(db, req.user, { limit, offset, q: req.query.q as string });
  res.json(result); // { items, total }
});
```

If any endpoint was returning `{ data, count }` or `{ rows, totalCount }`, normalize it.

---

# 7) Middleware sanity check

Your 401s were “No token provided” on some routes. Confirm **all** protected routes use the same auth middleware:

```ts
// server/middleware/auth.ts
import jwt from 'jsonwebtoken';
import { users } from '../db/schema';
import { db } from '../db/client';
import { eq } from 'drizzle-orm';

export async function authMiddleware(req, res, next) {
  const header = req.headers.authorization;
  if (!header?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'No token provided' });
  }
  const token = header.slice('Bearer '.length);

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string };
    const [user] = await db.select().from(users).where(eq(users.id, payload.userId)).limit(1);
    if (!user) return res.status(401).json({ error: 'Invalid user' });

    req.user = {
      id: user.id,
      isAdmin: user.isAdmin,
      shareAdminData: user.shareAdminData,
      adminId: user.adminId,
    };
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}
```

Then, attach to routes:

```ts
app.use('/api/watch-listings', authMiddleware);
app.use('/api/incoming-messages', authMiddleware);
// … etc
```

---

# 8) Quick checklist to fix the “admin data misplaced / All Records blank” feeling

* [ ] Confirm **All Records** page uses the **central `api` instance** (token attached).
* [ ] Ensure server `/watch-listings/search` returns **{ items, total }**.
* [ ] Replace every legacy manual SQL `'${id}'` construction with **Drizzle `inArray(...)`**.
* [ ] Use **the same access helper** (`getAccessibleUserIds`) on **every** data endpoint.
* [ ] If a team user toggles “Share admin data”: set `shareAdminData=true` and `adminId=<ADMIN_UUID>`.
* [ ] For non-sharing user: `shareAdminData=false` (they’ll need their own WA instance; they’ll only see self data).
* [ ] Restart server once after code changes to clear stale loaders.

---

## What to paste into your Replit/bolt prompt (ready text)

> **“Implement multi-tenant visibility with an admin sharing switch, fix UUID filtering, and make All Records load.”**
>
> * Add `adminId uuid` & `shareAdminData boolean` to `users` schema (nullable adminId).
> * Create `server/lib/access.ts` with `getAccessibleUserIds()` & `inArraySafe()` as above.
> * Update **every** list/search/export endpoint to filter by `inArraySafe(Table.userId, await getAccessibleUserIds(req.user))`.
> * Normalize `/api/watch-listings/search` to return `{ items, total }`.
> * Ensure **client** uses a single Axios instance with an Authorization interceptor (see `client/src/lib/api.ts`) and convert the Records page to use it.
> * Remove any manual SQL that builds `'uuid'` strings; use Drizzle `inArray`.
> * Verify `authMiddleware` attaches `{ id, isAdmin, shareAdminData, adminId }` on `req.user` and is applied to all protected routes.

---

If you want, send me:

* your `server/storage.ts` (getWatchListings) and one more endpoint (incoming messages),
* and your `client/src/pages/records.tsx` + `client/src/lib/api.ts`.

I’ll patch them line-by-line so you can drop them in.
